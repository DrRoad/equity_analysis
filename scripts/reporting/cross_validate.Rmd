---
title: "Cross Validation"
date: '`r strftime(Sys.time(), format = "%B %d, %Y")`'
output:
  html_document:
    df_print: paged
    toc: yes
    toc_float: yes
    toc_depth: '2'
    fig_width: 8
    fig_height: 4
---

```{r, include = F}
knitr::opts_chunk$set(echo = F,
                      warning = F,
                      message = F)

## Set options
options(scipen = 999, # prevent scientific notation on large numbers
        stringsAsFactors = F) # prevent R from turning everything to factors
```

# Summary of Trials

```{r, results = 'hide'}
# Define paths and load libraries
rm(list=ls())
working_directory <- here::here()
source(file.path(working_directory,"R/set_paths.R"))
source(file.path(working_directory,"results/parameters.R"))

library(pbo)
library(xts)
require(lattice)
require(latticeExtra)
require(grid)
library(ggplot2)
library(reshape2)
library(dygraphs)
# Time the script
allbegin <- Sys.time()

######################################################
# convenience function to convert tidy tibble to xts
tidy_tibble_to_xts <- function(tibble) {
  xts_tibble <- xts(tibble %>% select(-date), order.by=tibble$date)
  return(xts_tibble)
}

```


```{r}
######################################################
# read in returns
# remove date column because it is not required by pbo package
daily_returns <- tidy_tibble_to_xts(
  read_feather(file.path(results_directory, "daily_returns.feather")))
total_returns <- tidy_tibble_to_xts(
  read_feather(file.path(results_directory, "total_returns.feather")))

```

Number of Trials: `r ncol(daily_returns) - 1`

# Returns

```{r}

# Plot each trials total return on a separate axis
df_melt = melt(total_returns, id.vars = 'date')
#ggplot(df_melt, aes(x = date, y = value)) + 
#  geom_line() + 
#  facet_wrap(~ variable, scales = 'free_y', ncol = 1)

# Plot all returns on a single plot
#color <- rainbow(ncol(total_returns))
#ts.plot(total_returns, gpars= list(col=color))
#legend("topright", legend=colnames(total_returns), lty=1, col=color)
dygraph(total_returns, 
                main = "All Trials Normalised Total Returns", 
        ylab = "Indexed Value") %>%
  dyLegend(width = 600) %>%
  dyOptions(maxNumberWidth = 20, stackedGraph = FALSE) %>%
  dyRangeSelector %>%
  dyRebase(value=100) %>%
  dyHighlight(highlightSeriesOpts = list(strokeWidth = 3))
  
```

# Probability of Backtest Overfitting

To compute the probability of backtest overfitting, we need to define the Sharpe Ratio. We use the same Sharpe Ratio function defined in the `pbo` package vignette - 

```{r, echo = T}
sharpe <- function(x,rf=daily_risk_free_rate) {
  sr <- apply(x,2,function(col) {
    er = col - rf
    return(mean(er)/sd(er))
  })
  return(sr)
}

```

## Summary

Closer to 1 is more overfit
```{r}
my_pbo <- pbo(daily_returns,s=8,f=sharpe,threshold=0)
pbo_summary <- summary(my_pbo)
knitr::kable(pbo_summary, col.names = "Value") #closer to 1 pbo is more overfit

```

## Histogram
```{r}
histogram(my_pbo, type='density')
```

# Degradation
```{r}
xyplot(my_pbo,plotType="degradation")
```

# Stochastic Dominance
```{r}
xyplot(my_pbo,plotType="dominance",increment=0.001)
```

# Pairs
```{r}
xyplot(my_pbo,plotType="pairs")
```

# Ranks

```{r}
xyplot(my_pbo,plotType="ranks",ylim=c(0,20))
```

# Dotplot
```{r}
dotplot(my_pbo)
```

